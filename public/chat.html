<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureComm - Chat</title>
    <link rel="icon" type="image/png" href="logo.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image:
                linear-gradient(rgba(74, 222, 128, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(74, 222, 128, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none; z-index: -1;
        }

        /* Header */
        .header {
            position: fixed; top: 0; width: 100%; height: 80px;
            background: rgba(0, 0, 0, 0.95); backdrop-filter: blur(20px);
            z-index: 1000; display: flex; justify-content: space-between;
            align-items: center; padding: 0 30px;
            border-bottom: 3px solid rgba(74, 222, 128, 0.4);
        }

        .logo {
            font-size: 24px; font-weight: bold; color: #4ade80;
            text-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
        }

        .header-nav { display: flex; gap: 15px; }

        .nav-btn {
            padding: 8px 20px; border: 2px solid #4ade80; background: transparent;
            color: #4ade80; border-radius: 6px; cursor: pointer; font-weight: bold;
            font-family: 'Courier New', monospace; text-transform: uppercase;
            letter-spacing: 1px; transition: all 0.3s ease; font-size: 12px;
        }

        .nav-btn:hover {
            background: rgba(74, 222, 128, 0.15);
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.4);
            transform: translateY(-2px);
        }
        
        /* Main Container */
        .main-container { display: flex; height: calc(100vh - 80px); margin-top: 80px; }
        .main-content { flex: 1; display: flex; }

        /* Chat Interface Styles */
        .chat-container { display: flex; height: 100%; width: 100%; }
        .chat-list { width: 320px; background: rgba(0, 0, 0, 0.6); border-right: 2px solid rgba(74, 222, 128, 0.3); display: flex; flex-direction: column; }
        .search-section { padding: 15px; border-bottom: 1px solid rgba(74, 222, 128, 0.3); }
        .search-input { width: 100%; padding: 12px; background: rgba(0, 0, 0, 0.8); border: 2px solid rgba(74, 222, 128, 0.3); border-radius: 20px; color: #fff; font-size: 14px; outline: none; font-family: 'Courier New', monospace; }
        .chat-items { flex: 1; overflow-y: auto; padding: 10px; }
        .chat-items::-webkit-scrollbar { width: 6px; }
        .chat-items::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); }
        .chat-items::-webkit-scrollbar-thumb { background: rgba(74, 222, 128, 0.6); }
        .chat-item { display: flex; align-items: center; gap: 12px; padding: 12px; border: 1px solid transparent; border-radius: 10px; margin-bottom: 8px; cursor: pointer; transition: all 0.3s ease; }
        .chat-item:hover, .chat-item.active { background: rgba(74, 222, 128, 0.1); border-color: rgba(74, 222, 128, 0.5); }
        .chat-avatar { width: 45px; height: 45px; border-radius: 50%; background: rgba(74, 222, 128, 0.3); display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold; color: #4ade80; flex-shrink: 0; }
        .chat-info { flex: 1; overflow: hidden; }
        .chat-name { font-size: 14px; font-weight: bold; color: #e2e8f0; margin-bottom: 4px; }
        .chat-preview { font-size: 12px; color: #64748b; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-meta { text-align: right; }
        .chat-time { font-size: 10px; color: #64748b; margin-bottom: 8px; }
        .unread-badge { background: #4ade80; color: #000; font-size: 10px; font-weight: bold; padding: 3px 6px; border-radius: 10px; }
        .chat-window { flex: 1; display: flex; flex-direction: column; background: rgba(0, 0, 0, 0.4); }
        .chat-placeholder { flex: 1; display: flex; align-items: center; justify-content: center; color: #64748b; font-size: 1.2em; }
        .chat-header { padding: 20px; border-bottom: 2px solid rgba(74, 222, 128, 0.3); background: rgba(0, 0, 0, 0.6); display: flex; align-items: center; gap: 15px; justify-content: space-between;}
        .chat-title { font-size: 18px; font-weight: bold; color: #4ade80; }
        .chat-status { font-size: 12px; color: #94a3b8; }
        .chat-messages { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; }
        .chat-messages::-webkit-scrollbar { width: 6px; }
        .chat-messages::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); }
        .chat-messages::-webkit-scrollbar-thumb { background: rgba(74, 222, 128, 0.6); }
        .message { max-width: 70%; padding: 12px 18px; border-radius: 18px; font-size: 14px; line-height: 1.5; position: relative; }
        .message.sent { align-self: flex-end; background: linear-gradient(45deg, #4ade80, #22d3ee); color: #000; border-bottom-right-radius: 5px; }
        .message.received { align-self: flex-start; background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); color: #e2e8f0; border-bottom-left-radius: 5px; }
        .message-time { font-size: 10px; opacity: 0.7; margin-top: 5px; display: block; }
        .chat-input-section { padding: 20px; border-top: 2px solid rgba(74, 222, 128, 0.3); background: rgba(0, 0, 0, 0.6); }
        .chat-input-container { display: flex; gap: 10px; }
        .chat-input { flex: 1; padding: 12px; background: rgba(0, 0, 0, 0.8); border: 2px solid rgba(74, 222, 128, 0.3); border-radius: 10px; color: #fff; font-size: 14px; outline: none; font-family: 'Courier New', monospace; resize: none; }
        .send-btn { padding: 12px 20px; background: linear-gradient(45deg, #4ade80, #22d3ee); border: none; border-radius: 10px; color: #000; font-weight: bold; cursor: pointer; font-size: 14px; }
        
        /* --- MODIFIED/NEW STYLES --- */
        .delete-chat-btn {
            padding: 6px 12px;
            border: 2px solid #ef4444; /* Red color for delete */
            background: transparent;
            color: #ef4444;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            font-size: 10px;
            margin-left: auto; /* Push it to the right */
        }

        .delete-chat-btn:hover {
            background: rgba(239, 68, 68, 0.15); /* Red hover */
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
            transform: translateY(-2px);
        }

        .message {
            position: relative; /* For positioning the delete button */
        }
        .delete-msg-btn {
            position: absolute;
            top: 2px;
            font-size: 14px;
            cursor: pointer;
            display: none; /* Hide by default */
            font-weight: bold;
            opacity: 0.7;
            padding: 0 5px;
            font-size: 16px; /* Make emoji visible */
            right: 8px;
            color: #555;
        }
        .message:hover .delete-msg-btn {
            display: block; /* Show on hover */
        }
        .message.sent .delete-msg-btn {
            right: 8px;
            color: #555; /* Darker on the bright bubble */
        }
        /* We won't show this on received, but just in case */
        .message.received .delete-msg-btn { 
            display: none;
        }

        .message.received:hover .delete-msg-btn {
             display: block; /* Show on received as well */
             color: #94a3b8; /* Lighter color */
             right: 8px; /* Align with sent messages */
        }
        .delete-msg-btn:hover {
            opacity: 1;
        }
        /* --- END OF MODIFIED/NEW STYLES --- */
        /* --- STYLES FOR DELETE MODAL --- */
        .delete-modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 3000;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px); /* Match your site blur */
            justify-content: center;
            align-items: center;
        }

        .delete-modal-content {
            background: rgba(0, 0, 0, 0.9); /* Dark background */
            border: 2px solid rgba(74, 222, 128, 0.3); /* Green border */
            border-radius: 15px; /* Match your other modals */
            padding: 30px;
            width: 90%;
            max-width: 350px; /* A bit wider */
            text-align: center;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
            font-family: 'Courier New', monospace;
        }

        .delete-modal-content h3 {
            color: #4ade80; /* SecureComm Green */
            margin-bottom: 25px;
            font-size: 1.4em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .delete-modal-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .delete-modal-btn {
            padding: 12px;
            border: 2px solid;
            border-radius: 8px; /* Match other buttons */
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 14px;
            transition: all 0.3s ease;
            background: transparent;
        }
        
        .delete-modal-btn:hover {
            transform: translateY(-2px); /* Hover effect */
        }

        /* "Delete for Me" Button Style (Yellow Warning) */
        .delete-modal-btn.delete-me {
            border-color: #ef4444;
            color: #ef4444;
        }
        .delete-modal-btn.delete-me:hover {
            background: rgba(239, 68, 68, 0.1);
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
        }
        
        /* "Delete for Everyone" Button Style (Red Danger) */
        .delete-modal-btn.delete-all {
            border-color: #ef4444;
            color: #ef4444;
        }
        .delete-modal-btn.delete-all:hover {
            background: rgba(239, 68, 68, 0.1);
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
        }
        
        /* "Cancel" Button Style (Green/Neutral) */
        .delete-modal-btn.delete-cancel {
            border-color: #64748b; /* Gray */
            color: #64748b;
        }
        .delete-modal-btn.delete-cancel:hover {
            background: rgba(100, 116, 139, 0.1);
            border-color: #4ade80; /* Hover to green */
            color: #4ade80;
        }


        /* --- MODIFY EXISTING .delete-msg-btn --- */
        .delete-msg-btn {
            position: absolute;
            top: 2px;
            font-size: 20px; /* Larger for the 'x' */
            line-height: 1; /* Align it */
            cursor: pointer;
            display: none;
            font-weight: bold;
            opacity: 0.7;
            padding: 0 5px;
            right: 8px; /* Position on the right */
            color: #555; /* Dark on light bubble */
        }
        .message:hover .delete-msg-btn {
            display: block; /* Show on hover */
        }
        .message.received:hover .delete-msg-btn {
            display: block;
            color: #94a3b8; /* Lighter on dark bubble */
        }
        .delete-msg-btn:hover {
            opacity: 1;
        }
            

        /* MODAL STYLES */

        .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); justify-content: center; align-items: center; }
        .modal-content { background: rgba(10, 10, 20, 0.95); padding: 30px; border: 2px solid #4ade80; border-radius: 15px; width: 90%; max-width: 700px; position: relative; box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5); }
        .modal-content h2 { color: #4ade80; margin-bottom: 20px; text-align: center; }
        .modal-content h3 { color: #22d3ee; margin-bottom: 15px; }
        .close-btn { position: absolute; top: 15px; right: 20px; font-size: 28px; color: #4ade80; cursor: pointer; line-height: 1; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 10px; font-weight: bold; color: #94a3b8; text-transform: uppercase; font-size: 12px; }
        .form-textarea { width: 100%; min-height: 100px; padding: 12px; background: rgba(0, 0, 0, 0.8); border: 2px solid rgba(74, 222, 128, 0.3); border-radius: 8px; color: #fff; font-size: 14px; font-family: 'Courier New', monospace; resize: vertical; }
        .radio-group, .checkbox-group { display: flex; gap: 20px; }
        .radio-group label, .checkbox-group label { display: flex; align-items: center; cursor: pointer; color: #e2e8f0; text-transform: none; font-size: 14px; }
        input[type="radio"], input[type="checkbox"] { appearance: none; -webkit-appearance: none; width: 18px; height: 18px; border: 2px solid #4ade80; margin-right: 10px; vertical-align: middle; transition: all 0.2s; }
        input[type="radio"] { border-radius: 50%; }
        input[type="checkbox"] { border-radius: 4px; }
        input[type="radio"]:checked, input[type="checkbox"]:checked { background-color: #4ade80; box-shadow: 0 0 10px rgba(74, 222, 128, 0.5); }
        .modal-buttons { display: flex; justify-content: flex-end; gap: 15px; margin-top: 30px; }
        .modal-btn { padding: 10px 25px; border-radius: 6px; font-weight: bold; font-family: 'Courier New', monospace; text-transform: uppercase; cursor: pointer; transition: all 0.3s ease; }
        .btn-send { background: #4ade80; color: #000; border: none; }
        .btn-cancel { background: transparent; color: #ef4444; border: 2px solid #ef4444; }
        
        #intraUnitSelectModal .modal-content, #interUnitSelectModal .modal-content { max-width: 400px; }
        .recipients-list { max-height: 200px; overflow-y: auto; padding: 10px; background: rgba(0,0,0,0.4); border-radius: 8px; }
        .recipient-item { margin-bottom: 10px; }
        
        .btn-done { background: linear-gradient(45deg, #22d3ee, #4ade80); color: #000; border: none; }
        .btn-done:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(34, 211, 238, 0.4); }
        .btn-done:disabled { background: #555; color: #888; cursor: not-allowed; opacity: 0.5; box-shadow: none; transform: none; }

        .modal-btn:hover { transform: translateY(-2px); }
        .btn-send:hover { box-shadow: 0 5px 15px rgba(74, 222, 128, 0.4); }
        .btn-cancel:hover { background: rgba(239, 68, 68, 0.1); box-shadow: 0 5px 15px rgba(239, 68, 68, 0.4); }
        
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">SecureComm Command</div>
        <div class="header-nav">
            <a href="main.html"><button class="nav-btn">Back to Dashboard</button></a>
            <button class="nav-btn" onclick="openPostQuestionModal()">Hierarchy</button>
        </div>
    </div>

    <div class="main-container">
        <div class="main-content">
            <div class="chat-container">
                <div class="chat-list">
                    <div class="search-section">
                        <input type="text" class="search-input" placeholder="Search by Service-Id">
                    </div>
                    <div class="chat-items">
                        </div>
                </div>
                <div class="chat-window">
                    <div class="chat-placeholder"><p>Select a contact to view messages</p></div>
                    <div class="chat-header" style="display: none;">
                        <div class="chat-avatar" id="chat-header-avatar"></div>
                        <div>
                            <div class="chat-title" id="chat-title"></div>
                            <div class="chat-status" id="chat-status"></div>
                        </div>
                        <button class="delete-chat-btn" id="deleteChatBtn" title="Hide this conversation">Hide</button> </div>
                    <div class="chat-messages" style="display: none;"></div>
                    <div class="chat-input-section" style="display: none;">
                        <div class="chat-input-container">
                            <textarea class="chat-input" placeholder="Type your message..."></textarea>
                            <button class="send-btn">Send</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="postQuestionModal">
        <div class="modal-content">
            <span class="close-btn" onclick="closePostQuestionModal()">&times;</span>
            <h2>Post a Message or Question</h2>
            <div class="form-group"><label for="messageText">Message:</label><textarea id="messageText" class="form-textarea" placeholder="Type your message..."></textarea></div>
            <div class="form-group"><label>Post As:</label><div class="radio-group"><label><input type="radio" name="anonymity" value="public" checked> Not Anonymous</label><label><input type="radio" name="anonymity" value="anonymous"> Anonymous</label></div></div>
            <div class="form-group"><label>Visible To:</label><div class="checkbox-group"><label><input type="checkbox" id="interUnitCheckbox"> Inter-Unit</label><label><input type="checkbox" id="intraUnitCheckbox"> Intra-Unit</label></div></div>
            <div class="modal-buttons"><button class="modal-btn btn-cancel" onclick="cancelPostQuestion()">Cancel</button><button class="modal-btn btn-send" onclick="submitQuestion()">Send</button></div>
        </div>
    </div>
    <div class="modal" id="recipientSelectModal">
        <div class="modal-content">
            <h3 id="recipientModalTitle" style="color: #22d3ee; margin-bottom: 15px;">Select Recipients</h3>
            <div class="recipients-list" id="recipientModalList" style="max-height: 300px; overflow-y: auto; padding: 10px; background: rgba(0,0,0,0.4); border-radius: 8px;">
                <p style="color: #64748b;">Loading...</p>
            </div>
            <div class="modal-buttons" style="margin-top: 20px;">
                <button class="modal-btn btn-cancel" onclick="cancelRecipientSelection()">Cancel</button>
                <button class="modal-btn btn-done" id="recipientDoneBtn" onclick="closeRecipientModal()" disabled>Done</button>
            </div>
        </div>
    </div>
    <div class="delete-modal" id="deleteMessageModal">
        <div class="delete-modal-content">
            <h3>Delete Message</h3>
            <div class="delete-modal-buttons">
                <button class="delete-modal-btn delete-me" id="deleteForMeBtn">Delete for Me</button>
                <button class="delete-modal-btn delete-all" id="deleteForEveryoneBtn">Delete for Everyone</button>
                <button class="delete-modal-btn delete-cancel" onclick="closeDeleteModal()">Cancel</button>
            </div>
        </div>
    </div>
    <script>
    // --- GLOBAL VARS ---
    let loggedInMilitaryId = null;
    let currentOpenChatState = { id: null, anonymous: false };
    let myPrivateKey = null; // Will hold our decrypted private key
    let keyCache = new Map(); // Caches public keys of other users
    let currentMessageToDelete = null;
    let selectedRecipients = [];
    let myUnitId = null;
    let allProfilesCache = []; // Caches all profiles for sorting
    let currentRecipientModal = null;

    // --- DOM ELEMENTS ---
    const chatList = document.querySelector('.chat-items');
    const chatWindow = document.querySelector('.chat-window');
    const chatPlaceholder = chatWindow.querySelector('.chat-placeholder');
    const chatHeader = chatWindow.querySelector('.chat-header');
    const chatMessages = chatWindow.querySelector('.chat-messages');
    const chatInputSection = chatWindow.querySelector('.chat-input-section');
    const sendButton = document.querySelector('.send-btn');
    const chatInput = document.querySelector('.chat-input');
    const searchInput = document.querySelector('.search-input');
    const deleteChatBtn = document.getElementById('deleteChatBtn');
    const recipientSelectModal = document.getElementById('recipientSelectModal');
    const recipientModalTitle = document.getElementById('recipientModalTitle');
    const recipientModalList = document.getElementById('recipientModalList');
    const recipientDoneBtn = document.getElementById('recipientDoneBtn');


    // ======================================================
    // --- START: CRYPTO FUNCTIONS (Ported from crypto-utils.js) ---
    // =Warning: This is for educational purposes and is not secure.
    // ======================================================

    // Modular exponentiation (base^exp % mod) using BigInt
    const power = (base, exp, mod) => {
        let res = 1n;
        base %= mod;
        while (exp > 0n) {
        if (exp % 2n === 1n) res = (res * base) % mod;
        base = (base * base) % mod;
        exp /= 2n;
        }
        return res;
    };

    // Miller-Rabin primality test
    const isProbablyPrime = (n, k = 5) => {
        if (n <= 1n || n === 4n) return false;
        if (n <= 3n) return true;
        let d = n - 1n;
        while (d % 2n === 0n) d /= 2n;
        for (let i = 0; i < k; i++) {
        const a = 2n + BigInt(Math.floor(Math.random() * Number(n - 4n)));
        let x = power(a, d, n);
        if (x === 1n || x === n - 1n) continue;
        let isWitness = true;
        let tempD = d;
        while (tempD < n - 1n) {
            x = (x * x) % n;
            if (x === n - 1n) { isWitness = false; break; }
            tempD *= 2n;
        }
        if (isWitness) return false;
        }
        return true;
    };

    // Extended Euclidean Algorithm
    const extendedEuclideanAlgorithm = (a, b) => {
        if (a === 0n) return [b, 0n, 1n];
        const [gcd, x1, y1] = extendedEuclideanAlgorithm(b % a, a);
        const x = y1 - (b / a) * x1;
        const y = x1;
        return [gcd, x, y];
    };

    const modInverse = (a, m) => {
        const [gcd, x] = extendedEuclideanAlgorithm(a, m);
        if (gcd !== 1n) throw new Error('Inverse does not exist');
        return (x % m + m) % m;
    };

    // Simple seeded pseudo-random number generator (LCG)
    const seededPseudoRandom = (seed) => {
        let state = seed;
        const m = 2n ** 31n - 1n;
        const a = 1103515245n;
        const c = 12345n;
        return () => {
        state = (a * state + c) % m;
        return state;
        };
    };

    // Function to find a prime
    const findPrime = (bits, prng) => {
        const min = 2n ** (BigInt(bits) - 1n);
        const max = 2n ** BigInt(bits) - 1n;
        while (true) {
        const p = (prng() % (max - min)) + min;
        if (p % 2n !== 0n && isProbablyPrime(p)) return p;
        }
    };

    // Main key generation function
    const generateKeys = (password, salt, bits = 64) => {
        let seed = 1n;
        const combined = password + salt;
        for (let i = 0; i < combined.length; i++) {
        seed = (seed * 31n + BigInt(combined.charCodeAt(i))) % (2n ** 31n - 1n);
        }
        const prng = seededPseudoRandom(seed);
        let p = findPrime(bits, prng);
        let q = findPrime(bits, prng);
        while (p === q) q = findPrime(bits, prng);
        const n = p * q;
        const phi_n = (p - 1n) * (q - 1n);
        const e = 65537n;
        const d = modInverse(e, phi_n);
        return {
        publicKey: { n, e },
        privateKey: { n, d },
        };
    };

    /**
     * Encrypts a string using RSA (char by char - INSECURE).
     * @param {string} plaintext The message to encrypt.
     * @param {object} publicKey {n: string, e: string}
     * @returns {string} Comma-separated list of encrypted char codes.
     */
    function encryptMessage(plaintext, publicKey) {
        const e = BigInt(publicKey.e);
        const n = BigInt(publicKey.n);
        let cipherParts = [];
        for (let i = 0; i < plaintext.length; i++) {
            const charCode = BigInt(plaintext.charCodeAt(i));
            const encryptedChar = power(charCode, e, n);
            cipherParts.push(encryptedChar.toString());
        }
        return cipherParts.join(',');
    }

    /**
     * Decrypts an RSA-encrypted string (char by char).
     * @param {string} ciphertext Comma-separated list of encrypted char codes.
     * @param {object} privateKey {n: BigInt, d: BigInt}
     * @returns {string} The decrypted plaintext.
     */
    function decryptMessage(ciphertext, privateKey) {
        const d = privateKey.d;
        const n = privateKey.n;
        let plain = '';
        const cipherParts = ciphertext.split(',');
        for (const part of cipherParts) {
            if (part === '') continue;
            const charCode = BigInt(part);
            const decryptedChar = power(charCode, d, n);
            plain += String.fromCharCode(Number(decryptedChar));
        }
        return plain;
    }

    /**
     * Helper to fetch and cache public keys.
     */
    async function fetchKey(militaryId) {
        if (keyCache.has(militaryId)) {
            return keyCache.get(militaryId);
        }
        const response = await fetch(`/api/profile/key/${militaryId}`);
        const data = await response.json();
        if (!data.success) throw new Error(data.error);
        keyCache.set(militaryId, data.publicKey);
        return data.publicKey;
    }

    let ws = null;
let reconnectInterval = null;
let isIntentionalDisconnect = false;

/**
 * Connects to the WebSocket server
 */
function connectWebSocket() {
    if (ws && ws.readyState === WebSocket.OPEN) {
        console.log('WebSocket already connected');
        return;
    }

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}`;
    
    console.log('üîå Connecting to WebSocket:', wsUrl);
    
    ws = new WebSocket(wsUrl);

    ws.onopen = () => {
        console.log('‚úÖ WebSocket connected');
        
        // Authenticate with the server
        ws.send(JSON.stringify({
            type: 'auth',
            militaryId: loggedInMilitaryId
        }));

        // Clear any reconnection attempts
        if (reconnectInterval) {
            clearInterval(reconnectInterval);
            reconnectInterval = null;
        }

        // Update UI to show connection status
        updateConnectionStatus(true);
    };

    ws.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            handleWebSocketMessage(data);
        } catch (error) {
            console.error('‚ùå Error parsing WebSocket message:', error);
        }
    };

    ws.onerror = (error) => {
        console.error('‚ùå WebSocket error:', error);
        updateConnectionStatus(false);
    };

    ws.onclose = () => {
        console.log('üîå WebSocket disconnected');
        updateConnectionStatus(false);
        
        // Attempt to reconnect unless it was intentional
        if (!isIntentionalDisconnect) {
            attemptReconnect();
        }
    };
}

/**
 * Handles incoming WebSocket messages
 */
async function handleWebSocketMessage(data) {
    console.log('üì® Received WebSocket message:', data.type);

    switch (data.type) {
        case 'auth_success':
            console.log('‚úÖ WebSocket authentication successful');
            break;

        case 'new_message':
            await handleNewMessageNotification(data.message);
            break;

        case 'typing':
            handleTypingIndicator(data);
            break;

        default:
            console.log('Unknown message type:', data.type);
    }
}

/**
 * Handles real-time message notifications
 */
async function handleNewMessageNotification(message) {
    console.log('üì¨ New message received via WebSocket');

    // Reload chat list to show new conversation/update preview
    await loadChatList();

    // If the chat is currently open with this person, decrypt and display
    const isFromCurrentChat = 
        (message.senderId === currentOpenChatState.id && message.receiverId === loggedInMilitaryId) ||
        (message.receiverId === currentOpenChatState.id && message.senderId === loggedInMilitaryId);

    if (isFromCurrentChat && message.isAnonymous === currentOpenChatState.anonymous) {
        const isSent = message.senderId === loggedInMilitaryId;
        const msgTime = new Date(message.createdAt).toLocaleTimeString([], { 
            hour: '2-digit', 
            minute: '2-digit' 
        });
        
        let messageText = "";
        
        try {
            if (isSent) {
                // This shouldn't happen (we already added it), but just in case
                messageText = message.senderCopy ? 
                    decryptMessage(message.senderCopy, myPrivateKey) : 
                    "[Sent by You]";
            } else {
                // Decrypt the received message
                messageText = decryptMessage(message.messageText, myPrivateKey);
            }
        } catch (e) {
            console.error('Decryption failed:', e);
            messageText = "[DECRYPTION FAILED]";
        }
        
        // Add message to UI
        appendMessage(messageText, isSent, msgTime, message._id, isSent);
    } else {
        // Show a notification or badge (optional)
        console.log('üí¨ New message in another conversation');
    }
}

/**
 * Handles typing indicators (optional feature)
 */
function handleTypingIndicator(data) {
    if (data.senderId === currentOpenChatState.id) {
        const statusElement = document.getElementById('chat-status');
        if (data.isTyping) {
            statusElement.textContent = 'typing...';
            statusElement.style.color = '#4ade80';
        } else {
            statusElement.textContent = currentOpenChatState.anonymous ? 
                'Anonymous Session' : 'Military ID';
            statusElement.style.color = '#94a3b8';
        }
    }
}

/**
 * Sends typing indicator to recipient (optional)
 */
function sendTypingIndicator(isTyping) {
    if (ws && ws.readyState === WebSocket.OPEN && currentOpenChatState.id) {
        ws.send(JSON.stringify({
            type: 'typing',
            recipientId: currentOpenChatState.id,
            isTyping: isTyping
        }));
    }
}

/**
 * Attempts to reconnect to WebSocket
 */
function attemptReconnect() {
    if (reconnectInterval) return;
    
    console.log('üîÑ Attempting to reconnect WebSocket...');
    
    reconnectInterval = setInterval(() => {
        if (!ws || ws.readyState === WebSocket.CLOSED) {
            connectWebSocket();
        }
    }, 5000); // Try every 5 seconds
}

/**
 * Updates UI to show connection status
 */
function updateConnectionStatus(isConnected) {
    // You can add a status indicator in your header
    // For now, just log it
    console.log(isConnected ? 'üü¢ Connected' : 'üî¥ Disconnected');
    
    // Optional: Add a visual indicator
    // const indicator = document.getElementById('connection-indicator');
    // if (indicator) {
    //     indicator.className = isConnected ? 'connected' : 'disconnected';
    // }
}

/**
 * Disconnects WebSocket (call on logout)
 */
function disconnectWebSocket() {
    isIntentionalDisconnect = true;
    if (ws) {
        ws.close();
        ws = null;
    }
    if (reconnectInterval) {
        clearInterval(reconnectInterval);
        reconnectInterval = null;
    }
}
    document.addEventListener('DOMContentLoaded', async function() {
    setupModalListeners();
    
    loggedInMilitaryId = localStorage.getItem('militaryId'); 

    if (!loggedInMilitaryId) {
        chatPlaceholder.innerHTML = '<p>Error: Not logged in. Please <a href="/login">log in</a>.</p>';
        return;
    }
    console.log(`Logged in as: ${loggedInMilitaryId}`);

    // Initialize crypto keys (your existing code)
    try {
        const sessionStr = sessionStorage.getItem('activeSession');
        if (!sessionStr) throw new Error('Active session not found. Please log in again.');
        
        const session = JSON.parse(sessionStr);
        const myPassword = session.password;
        const mySalt = session.profile.salt;
        myUnitId = session.profile.unitId;
        if (!myUnitId) throw new Error('Unit ID not found in session.');

        if (!myPassword || !mySalt) {
            throw new Error('Session is missing password or salt. Please log in again.');
        }

        console.log('üîê Re-generating private key from password and salt...');
        const { privateKey } = generateKeys(myPassword, mySalt);
        myPrivateKey = privateKey;
        console.log('‚úÖ Private key re-generated successfully.');

    } catch (error) {
        console.error('CRITICAL: Could not generate private key.', error);
        chatPlaceholder.innerHTML = `<p style="color: #ef4444;"><b>Fatal Error:</b> Could not initialize security keys. ${error.message}</p>`;
        return;
    }

    // üÜï NEW: Connect to WebSocket
    connectWebSocket();
    
    await loadChatList();
    await loadAllProfiles();
    
    // Event listeners (your existing code)
    searchInput.addEventListener('input', handleSearch);
    deleteChatBtn.addEventListener('click', hideCurrentChat);
    sendButton.addEventListener('click', sendMessage);
    
    chatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });

    // üÜï NEW: Add typing indicator (optional)
    let typingTimeout;
    chatInput.addEventListener('input', function() {
        sendTypingIndicator(true);
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
            sendTypingIndicator(false);
        }, 1000);
    });
    
    document.getElementById('deleteForMeBtn').addEventListener('click', deleteMessageForMe);
    document.getElementById('deleteForEveryoneBtn').addEventListener('click', deleteMessageForEveryone);

    // üÜï NEW: Disconnect WebSocket on page unload
    window.addEventListener('beforeunload', () => {
        disconnectWebSocket();
    });
});
    
    /**
     * Fetches the list of conversations from the API.
     */
    async function loadChatList() {
    try {
        const response = await fetch(`/api/chat/conversations/${loggedInMilitaryId}`);
        const data = await response.json();
        if (!data.success) throw new Error(data.error);
        
        chatList.innerHTML = '';
        
        if (data.conversations.length === 0) {
            chatList.innerHTML = '<p style="padding: 20px; color: #64748b;">No conversations found.</p>';
        }
        
        data.conversations.forEach(convo => {
            const chatItem = createChatItem(convo);
            chatList.appendChild(chatItem);
        });
    } catch (error) {
        console.error('Error loading chat list:', error);
        chatList.innerHTML = `<p style="padding: 20px; color: #ef4444;">Error loading chats.</p>`;
    }
}

    /**
     * --- NEW FUNCTION ---
     * Fetches all profiles from the server and caches them.
     */
    async function loadAllProfiles() {
        if (allProfilesCache.length > 0) return; // Don't re-fetch

        try {
            console.log("Fetching all profiles for recipient lists...");
            const response = await fetch(`/api/profiles/list/${loggedInMilitaryId}`);
            const data = await response.json();
            if (!data.success) throw new Error(data.error);
            allProfilesCache = data.profiles;
            console.log(`Cached ${allProfilesCache.length} profiles.`);
        } catch (error) {
            console.error('Failed to load profile list:', error);
            // You could add an error message to the modal here
        }
    }

    /**
     * Handles the search input field.
     */
    async function handleSearch() {
        const query = searchInput.value.trim();
        if (query === '') { await loadChatList(); return; }
        if (query.length < 2) { chatList.innerHTML = ''; return; }

        try {
            const response = await fetch(`/api/profiles/search/${loggedInMilitaryId}/${query}`);
            const data = await response.json();
            if (!data.success) throw new Error(data.error);
            chatList.innerHTML = '';
            if (data.results.length === 0) {
                chatList.innerHTML = '<p style="padding: 20px; color: #64748b;">No matching profiles found.</p>';
            } else {
                data.results.forEach(profile => {
                    const chatItem = createChatItem(profile); 
                    chatList.appendChild(chatItem);
                });
            }
        } catch (error) {
            console.error('Error during search:', error);
            chatList.innerHTML = `<p style="padding: 20px; color: #ef4444;">Error during search.</p>`;
        }
    }

    /**
     * Creates a single chat item element for the sidebar.
     */
    function createChatItem(convo) {
    const div = document.createElement('div');
    div.className = 'chat-item';
    div.dataset.contactId = convo.otherPartyId;
    div.dataset.isAnonymous = convo.isAnonymous; // ‚Üê Verify this line exists
    
    const msgTime = new Date(convo.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    
    // Sanitize preview text
    const previewText = document.createTextNode(convo.lastMessage).textContent;

    div.innerHTML = `
        <div class="chat-avatar">${convo.avatar}</div>
        <div class="chat-info">
            <div class="chat-name">${convo.name}</div>
            <div class="chat-preview">${previewText}</div>
        </div>
        <div class="chat-meta">
            <div class="chat-time">${msgTime}</div>
            ${convo.unread > 0 ? `<div class="unread-badge">${convo.unread}</div>` : ''}
        </div>
    `;
    
    // Pass isAnonymous flag to openChat
    div.addEventListener('click', () => openChat(
        convo.otherPartyId, 
        convo.name, 
        convo.avatar, 
        convo.isAnonymous // ‚Üê Verify this line exists
    ));
    
    return div;
}

    /**
 * Opens a chat window for a specific contact. (Handles Anonymous IDs)
 */
async function openChat(contactId, contactName, contactAvatar, isAnonymous) { // Accept the flag
    // --- UPDATE HOW STATE IS STORED ---
    currentOpenChatState = { id: contactId, anonymous: isAnonymous };

    // Highlight based on BOTH contactId and isAnonymous
    document.querySelectorAll('.chat-item').forEach(item => item.classList.remove('active'));
    const chatItem = document.querySelector(`.chat-item[data-contact-id='${contactId}'][data-is-anonymous='${isAnonymous}']`);
    if (chatItem) {
        chatItem.classList.add('active');
    } else {
        console.warn("Could not find chat item to highlight:", contactId, isAnonymous);
    }


    chatPlaceholder.style.display = 'none';
    chatHeader.style.display = 'flex';
    chatMessages.style.display = 'flex';
    chatInputSection.style.display = 'block';

    // Update header based on anonymity
    document.getElementById('chat-header-avatar').textContent = isAnonymous ? "AN" : contactAvatar;
    document.getElementById('chat-title').textContent = contactName; // Name is already correct from server (either ANON-ID or Real ID)
    document.getElementById('chat-status').textContent = isAnonymous ? "Anonymous Session" : "Military ID";
    
    // Update the title on the "Hide Chat" button based on the displayed name
    const currentChatName = document.getElementById('chat-title').textContent;
    document.getElementById('deleteChatBtn').title = `Hide conversation with ${currentChatName}`;
    document.getElementById('deleteChatBtn').textContent = "Hide";

    chatMessages.innerHTML = '<p style="color: #64748b; text-align: center;">Loading & Decrypting messages...</p>';

    try {
        // --- UPDATE FETCH URL ---
        // Pass the anonymous flag as a query parameter
        const response = await fetch(`/api/chat/history/${loggedInMilitaryId}/${contactId}?anonymous=${isAnonymous}`); 
        const data = await response.json();
        if (!data.success) throw new Error(data.error);

        chatMessages.innerHTML = ''; // Clear loading

        for (const msg of data.messages) {
            const isSent = msg.senderId === loggedInMilitaryId;
            const msgTime = new Date(msg.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            let messageText = "";
            let allowDelete = false;

            try {
                if (isSent) {
                    // We sent this. Decrypt our own copy.
                    if (!msg.senderCopy) {
                        messageText = "[Encrypted - Sent by You (Old)]";
                    } else {
                        messageText = decryptMessage(msg.senderCopy, myPrivateKey);
                    }
                    allowDelete = true; 
                } else {
                    // We received this. Decrypt the main text.
                    messageText = decryptMessage(msg.messageText, myPrivateKey);
                }
            } catch (e) {
                console.error('Decryption failed for message:', msg._id, e);
                messageText = "[DECRYPTION FAILED]";
            }
            
            appendMessage(messageText, isSent, msgTime, msg._id, allowDelete);
        }
        
        loadChatList(); // Update sidebar to potentially mark as read

    } catch (error) {
        console.error('Error loading chat history:', error);
        chatMessages.innerHTML = `<p style="padding: 20px; color: #ef4444; text-align: center;">Error loading messages: ${error.message}</p>`;
    }
}

        /**
         * Appends a single message bubble to the chat window. (REPLACE)
         */
        function appendMessage(text, isSent, time, messageId, allowDelete = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
            messageDiv.dataset.messageId = messageId;

            const safeText = document.createTextNode(text).textContent;
            
            let deleteBtnHtml = '';
            
            // Allow deleting our own sent messages OR any received message (for-me)
            if (messageId && (allowDelete || !isSent)) {
                 // Use a trash can icon and call the new modal function
                deleteBtnHtml = `<span class="delete-msg-btn" onclick="openDeleteModal(this, '${messageId}', ${isSent})" title="Delete message">&times;</span>`;
            }

            messageDiv.innerHTML = `${safeText}<span class="message-time">${time}</span>${deleteBtnHtml}`;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

    /**
         * Sends a new message via the API. (UPDATED for E2EE)
         */
        async function sendMessage() {
    const text = chatInput.value.trim();
    if (text === '' || !currentOpenChatState.id) return;

    let encryptedTextForReceiver;
    let encryptedTextForSelf;
    
    try {
        console.log(`Fetching public key for receiver ${currentOpenChatState.id}...`);
        const receiverKey = await fetchKey(currentOpenChatState.id);
        console.log('Encrypting message for receiver...');
        encryptedTextForReceiver = encryptMessage(text, receiverKey);
        
        console.log(`Fetching public key for self ${loggedInMilitaryId}...`);
        const selfKey = await fetchKey(loggedInMilitaryId);
        console.log('Encrypting message for self...');
        encryptedTextForSelf = encryptMessage(text, selfKey);

    } catch (error) {
        console.error('Encryption failed:', error);
        alert('Error: Could not get encryption keys. Cannot send message.');
        return;
    }

    const sentText = chatInput.value;
    chatInput.value = ''; 

    try {
        const messageData = {
            senderId: loggedInMilitaryId,
            receiverId: currentOpenChatState.id,
            messageText: encryptedTextForReceiver,
            senderCopy: encryptedTextForSelf,
            isAnonymous: currentOpenChatState.anonymous
        };
        
        const response = await fetch('/api/chat/send', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(messageData)
        });
        
        const data = await response.json();
        if (!data.success) throw new Error(data.error);
        
        const msg = data.message;
        const msgTime = new Date(msg.createdAt).toLocaleTimeString([], { 
            hour: '2-digit', 
            minute: '2-digit' 
        });
        
        // Add to UI immediately (sender's view)
        appendMessage(sentText, true, msgTime, msg._id, true);
        
        // The receiver will get it via WebSocket automatically
        await loadChatList();

    } catch (error) {
        console.error('Error sending message:', error);
        chatInput.value = sentText;
        alert('Failed to send message: ' + error.message);
    }
}

    /**
     * Hides the currently open conversation.
     */
    async function hideCurrentChat() {
        if (!currentOpenChatState.id) {
            alert('No chat selected.');
            return;
        }
        const contactName = document.getElementById('chat-title').textContent;
        const isConfirmed = confirm(`Are you sure you want to HIDE your conversation with ${contactName}? The history will be removed from your view, but not for them.`);
        if (!isConfirmed) return;
        
        try {
            const response = await fetch(`/api/chat/hide`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    myId: loggedInMilitaryId,
                    otherId: currentOpenChatState.id,
                    isAnonymous: currentOpenChatState.anonymous
                })
            });
            const data = await response.json();
            if (!data.success) throw new Error(data.error);
            
            console.log(`Successfully hid ${data.hiddenCount} messages.`);
            chatHeader.style.display = 'none';
            chatMessages.style.display = 'none';
            chatInputSection.style.display = 'none';
            chatPlaceholder.style.display = 'flex';
            currentOpenChatState = { id: null, anonymous: false };
            await loadChatList();

        } catch (error) {
            console.error('Error hiding chat:', error);
            alert('Failed to hide chat: ' + error.message);
        }
    }
    
    // --- START NEW FUNCTIONS (REPLACE deleteSingleMessage) ---

        /**
         * Opens the delete confirmation modal.
         */
        function openDeleteModal(buttonElement, messageId, isSent) {
            currentMessageToDelete = messageId; // Store the ID
            
            // Show/hide the "Delete for Everyone" button
            const deleteForEveryoneBtn = document.getElementById('deleteForEveryoneBtn');
            deleteForEveryoneBtn.style.display = isSent ? 'block' : 'none';

            // Show the modal
            document.getElementById('deleteMessageModal').style.display = 'flex';
        }

        /**
         * Closes the delete confirmation modal.
         */
        function closeDeleteModal() {
            document.getElementById('deleteMessageModal').style.display = 'none';
            currentMessageToDelete = null;
        }

        /**
         * Hides a single message for the current user (soft delete).
         */
        async function deleteMessageForMe() {
            const messageId = currentMessageToDelete;
            if (!messageId) return;

            try {
                const response = await fetch('/api/chat/message/hide', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messageId: messageId,
                        myId: loggedInMilitaryId
                    })
                });
                const data = await response.json();
                if (!data.success) throw new Error(data.error);

                // Remove from UI
                const messageDiv = document.querySelector(`.message[data-message-id='${messageId}']`);
                if (messageDiv) messageDiv.remove();
                
                closeDeleteModal();
                await loadChatList(); // Update sidebar in case it was the last message

            } catch (error) {
                console.error('Error deleting message for me:', error);
                alert('Failed to hide message: ' + error.message);
            }
        }
        
        /**
         * Deletes a single message for everyone (hard delete).
         * (This is your renamed deleteSingleMessage function)
         */
        async function deleteMessageForEveryone() {
            const messageId = currentMessageToDelete;
            if (!messageId) return;

            try {
                const response = await fetch('/api/chat/message', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messageId: messageId,
                        myId: loggedInMilitaryId
                    })
                });
                const data = await response.json();
                if (!data.success) throw new Error(data.error);

                // Remove from UI
                const messageDiv = document.querySelector(`.message[data-message-id='${messageId}']`);
                if (messageDiv) messageDiv.remove();

                closeDeleteModal();
                await loadChatList();

            } catch (error) {
                console.error('Error deleting message for everyone:', error);
                alert('Failed to delete message: ' + error.message);
            }
        }
        
        // --- END NEW FUNCTIONS ---
    
    // ======================================================
    // --- HIERARCHY / POSTING MODAL SCRIPT (DYNAMIC) ---
    // ======================================================
    
    // Get the main modal elements
    const postQuestionModal = document.getElementById('postQuestionModal');
    const intraUnitCheckbox = document.getElementById('intraUnitCheckbox');
    const interUnitCheckbox = document.getElementById('interUnitCheckbox');

    /**
     * Sets up listeners for the main modal's checkboxes.
     */
    function setupModalListeners() {
        intraUnitCheckbox.addEventListener('change', function() {
            if (this.checked) {
                openRecipientModal('intra');
            } else {
                // Clear Intra-Unit recipients from the list
                const intraUnitProfiles = allProfilesCache.filter(p => p.unitId === myUnitId).map(p => p.militaryId);
                selectedRecipients = selectedRecipients.filter(id => !intraUnitProfiles.includes(id));
                console.log('Cleared Intra-Unit. Total recipients:', selectedRecipients);
            }
        });

        interUnitCheckbox.addEventListener('change', function() {
            if (this.checked) {
                openRecipientModal('inter');
            } else {
                // Clear Inter-Unit recipients from the list
                const interUnitProfiles = allProfilesCache.filter(p => p.unitId !== myUnitId).map(p => p.militaryId);
                selectedRecipients = selectedRecipients.filter(id => !interUnitProfiles.includes(id));
                console.log('Cleared Inter-Unit. Total recipients:', selectedRecipients);
            }
        });
    }

    /**
     * Opens the dynamic recipient modal.
     */
    function openRecipientModal(type) {
        currentRecipientModal = type; // 'intra' or 'inter'
        recipientModalList.innerHTML = ''; // Clear old list
        recipientDoneBtn.disabled = false; // Enable by default

        let filteredProfiles = [];
        if (type === 'intra') {
            recipientModalTitle.textContent = 'Select Intra-Unit Recipients';
            filteredProfiles = allProfilesCache.filter(p => p.unitId === myUnitId);
        } else {
            recipientModalTitle.textContent = 'Select Inter-Unit Recipients';
            filteredProfiles = allProfilesCache.filter(p => p.unitId !== myUnitId);
        }

        if (filteredProfiles.length === 0) {
            recipientModalList.innerHTML = '<p style="color: #64748b; padding: 10px;">No profiles found.</p>';
        } else {
            // Generate new list
            filteredProfiles.forEach(profile => {
                // Pre-check if this ID is already in our global list
                const isChecked = selectedRecipients.includes(profile.militaryId) ? 'checked' : '';
                
                const html = `
                <div class="recipient-item checkbox-group" style="padding: 5px 0;">
                    <label>
                        <input type="checkbox" value="${profile.militaryId}" class="recipient-checkbox" ${isChecked}>
                        ${profile.militaryId} (Unit: ${profile.unitId} | Role: ${profile.roleId})
                    </label>
                </div>`;
                recipientModalList.innerHTML += html;
            });
        }
        
        // Attach listeners to the NEW checkboxes inside the modal
        const recipientCheckboxes = recipientModalList.querySelectorAll('.recipient-checkbox');
        
        function updateDoneButtonState() {
            // This function (re-defined inside) just controls the button
            const anyChecked = Array.from(recipientCheckboxes).some(checkbox => checkbox.checked);
            recipientDoneBtn.disabled = !anyChecked;
        }

        recipientCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', updateDoneButtonState);
        });
        
        // Check state on load
        updateDoneButtonState();
        
        recipientSelectModal.style.display = 'flex';
    }

    /**
     * Closes the recipient modal AND saves the state.
     */
    function closeRecipientModal() {
        recipientSelectModal.style.display = 'none';

        // Get all *possible* recipients that could have been in this modal
        const modalProfiles = (currentRecipientModal === 'intra')
            ? allProfilesCache.filter(p => p.unitId === myUnitId).map(p => p.militaryId)
            : allProfilesCache.filter(p => p.unitId !== myUnitId).map(p => p.militaryId);
        
        // Get selections *from this modal*
        const selectionsInModal = Array.from(
            recipientModalList.querySelectorAll('.recipient-checkbox:checked')
        ).map(cb => cb.value);

        // Filter out anyone from this modal who is *no longer* selected
        selectedRecipients = selectedRecipients.filter(id => !modalProfiles.includes(id));

        // Add back in everyone who *is* selected (prevents duplicates)
        selectionsInModal.forEach(id => {
            if (!selectedRecipients.includes(id)) {
                selectedRecipients.push(id);
            }
        });

        // If selectionsInModal is empty, it means the user un-checked everything
        if (selectionsInModal.length === 0) {
            // Un-check the main box that opened this modal
            if (currentRecipientModal === 'intra') {
                document.getElementById('intraUnitCheckbox').checked = false;
            } else if (currentRecipientModal === 'inter') {
                document.getElementById('interUnitCheckbox').checked = false;
            }
        }

        console.log(`Total recipients:`, selectedRecipients);
        currentRecipientModal = null;
    }

    /**
     * Cancels selection and unchecks the original box.
     */
    function cancelRecipientSelection() {
        // User clicked "Cancel", so don't save any changes from the recipient modal
        recipientSelectModal.style.display = 'none';
        
        // Also uncheck the main box that opened this modal
        if (currentRecipientModal === 'intra') {
            document.getElementById('intraUnitCheckbox').checked = false;
        } else if (currentRecipientModal === 'inter') {
            document.getElementById('interUnitCheckbox').checked = false;
        }
        
        currentRecipientModal = null;
    }

    // --- Main Hierarchy Modal Functions ---

    function openPostQuestionModal() { 
        postQuestionModal.style.display = 'flex';
    }
    
    function closePostQuestionModal() { 
        postQuestionModal.style.display = 'none';
    }

    /**
     * Resets the post modal to its default state and closes it.
     */
    function resetAndClosePostModal() {
        document.getElementById('messageText').value = '';
        document.getElementById('interUnitCheckbox').checked = false;
        document.getElementById('intraUnitCheckbox').checked = false;
        document.querySelector('input[name="anonymity"][value="public"]').checked = true;
        selectedRecipients = []; // Clear the global list
        closePostQuestionModal();
    }
    
    /**
     * Attached to the "Cancel" button to reset the form.
     */
    function cancelPostQuestion() {
        resetAndClosePostModal();
    }

    /**
     * Submits the message from the hierarchy modal.
     * Now sends 1-to-1 encrypted chats if "Not Anonymous" is checked.
     */
    async function submitQuestion() {
    const messageText = document.getElementById('messageText').value.trim();
    const isAnonymous = document.querySelector('input[name="anonymity"]:checked').value === 'anonymous';

    if (messageText === '') {
        alert('Please enter a message before sending.');
        return;
    }

    const isInterChecked = document.getElementById('interUnitCheckbox').checked;
    const isIntraChecked = document.getElementById('intraUnitCheckbox').checked;
    
    if (!isInterChecked && !isIntraChecked) {
        alert('Please select who the message is visible to (Inter-Unit or Intra-Unit).');
        return;
    }

    if (selectedRecipients.length === 0) {
        alert('Please select at least one recipient using the "Visible To" checkboxes.');
        return;
    }

    console.log(`üì§ Sending ${isAnonymous ? 'ANONYMOUS' : 'non-anonymous'} message to ${selectedRecipients.length} recipients...`);
    
    let successCount = 0;
    let failCount = 0;
    
    const sendBtn = postQuestionModal.querySelector('.btn-send');
    sendBtn.disabled = true;
    sendBtn.textContent = 'SENDING...';

    // Send one encrypted message to each recipient
    for (const recipientId of selectedRecipients) {
        try {
            console.log(`   ‚Üí Sending to ${recipientId}...`);
            
            // Get recipient's public key
            const receiverKey = await fetchKey(recipientId);
            
            // Get our own public key (for self-copy)
            const selfKey = await fetchKey(loggedInMilitaryId);
            
            // Encrypt for receiver
            const encryptedTextForReceiver = encryptMessage(messageText, receiverKey);
            
            // Encrypt for self
            const encryptedTextForSelf = encryptMessage(messageText, selfKey);

            // Send to server
            const messageData = {
                senderId: loggedInMilitaryId,
                receiverId: recipientId,
                messageText: encryptedTextForReceiver,
                senderCopy: encryptedTextForSelf,
                isAnonymous: isAnonymous // ‚Üê Verify this line exists
            };

            const response = await fetch('/api/chat/send', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(messageData)
            });

            const data = await response.json();
            if (!data.success) throw new Error(`Server error for ${recipientId}`);
            
            successCount++;
            console.log(`   ‚úÖ Sent to ${recipientId}`);

        } catch (error) {
            console.error(`   ‚ùå Failed to send to ${recipientId}:`, error);
            failCount++;
        }
    }

    sendBtn.disabled = false;
    sendBtn.textContent = 'SEND';
    
    alert(`Message sending complete.\n\nSuccessfully sent: ${successCount}\nFailed to send: ${failCount}`);

    await loadChatList();
    resetAndClosePostModal();
}
</script>
</body>
</html>